{"ast":null,"code":"import _defineProperty from \"D:/kdxf/githubpage/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-runtime\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n/*\n  useMemo和shouldComponentUpdate类似作用，在渲染过程中避免重复渲染的问题；\n  当状态或者父组件传来的属性更新时，更新组件。\n\n  1. useMemo 就是用的 Memoization 来提高性能的；\n  2. Memoization 是 JavaScript 中的一种缓存技术；\n  如果我们有CPU密集型操作，我们可以通过将初始操作的结果储存在缓存中来优化使用，如果操作必然会再次执行，我们将不会麻烦再次使用CPU，因为相同的结果储存在某个地方，我们只是简单地返回结果。\n\n  记住这个是以空间换速度，所以最好确定你是否值得这么做，有些场景很有必要使用。\n  useMemo是一个函数，有两个参数，第一个参数是函数，第二个参数是个数组。\n  useMemo(() =>, [默认可以不写， 作用类似于 useEffect])\n\n\n  useMemo 和 useEffect 的执行时间不同， useEffect是在componentDidMount以后执行的，而useMemo是在组件渲染过程中执行的，先于useEffect。\n */\n\n/* eslint-disable no-unused-vars */\nimport React, { useEffect, useState, useMemo } from 'react';\nimport ChildMemo from '@/components/useMemo/childMemo';\n\nvar UseMemoDemo = function UseMemoDemo() {\n  var _useState = useState(0),\n      count = _useState[0],\n      setCount = _useState[1];\n\n  var _useState2 = useState(0),\n      num = _useState2[0],\n      setNum = _useState2[1]; // useEffect(() => {\n  //   console.log('useEffect');\n  // });\n\n\n  var res = useMemo(function () {\n    console.log('useMemo');\n    return {\n      count: count,\n      num: num\n    };\n  }, [count]); // 空数组就一个都不更新, 传count，点击add num就不更新，点击add count一并更新；\n\n  return /*#__PURE__*/_jsxs(_Fragment, {\n    children: [/*#__PURE__*/_jsxs(\"div\", {\n      children: [/*#__PURE__*/_jsx(\"h2\", {\n        children: \"\\u8BA1\\u6570\\u5668:\"\n      }), \" count\\uFF1A--- \", res.count, /*#__PURE__*/_jsx(\"br\", {}), \"num: --- \", res.num]\n    }), /*#__PURE__*/_jsx(\"button\", {\n      type: \"button\",\n      onClick: function onClick() {\n        return setCount(count + 1);\n      },\n      children: \"add count\"\n    }), /*#__PURE__*/_jsx(\"button\", {\n      type: \"button\",\n      onClick: function onClick() {\n        return setNum(num + 1);\n      },\n      children: \"add num\"\n    }), /*#__PURE__*/_jsx(\"hr\", {}), /*#__PURE__*/_jsx(ChildMemo, _objectSpread({}, {\n      count: count,\n      num: num\n    }))]\n  });\n};\n\nexport default UseMemoDemo;","map":null,"metadata":{},"sourceType":"module"}