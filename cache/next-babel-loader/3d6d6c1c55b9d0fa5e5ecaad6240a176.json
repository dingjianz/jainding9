{"ast":null,"code":"import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-runtime\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/*\r\n  useMemo和shouldComponentUpdate类似作用，在渲染过程中避免重复渲染的问题；\r\n  当状态或者父组件传来的属性更新时，更新组件。\r\n\r\n  1. useMemo 就是用的 Memoization 来提高性能的；\r\n  2. Memoization 是 JavaScript 中的一种缓存技术；\r\n  如果我们有CPU密集型操作，我们可以通过将初始操作的结果储存在缓存中来优化使用，如果操作必然会再次执行，我们将不会麻烦再次使用CPU，因为相同的结果储存在某个地方，我们只是简单地返回结果。\r\n\r\n  记住这个是以空间换速度，所以最好确定你是否值得这么做，有些场景很有必要使用。\r\n  useMemo是一个函数，有两个参数，第一个参数是函数，第二个参数是个数组。\r\n  useMemo(() =>, [默认可以不写， 作用类似于 useEffect])\r\n\r\n\r\n  useMemo 和 useEffect 的执行时间不同， useEffect是在componentDidMount以后执行的，而useMemo是在组件渲染过程中执行的，先于useEffect。\r\n */\n\n/* eslint-disable no-unused-vars */\nimport React, { useEffect, useState, useMemo } from 'react';\nimport ChildMemo from '@/components/useMemo/childMemo';\n\nconst UseMemoDemo = () => {\n  const {\n    0: count,\n    1: setCount\n  } = useState(0);\n  const {\n    0: num,\n    1: setNum\n  } = useState(0); // useEffect(() => {\n  //   console.log('useEffect');\n  // });\n\n  const res = useMemo(() => {\n    console.log('useMemo');\n    return {\n      count,\n      num\n    };\n  }, [count]); // 空数组就一个都不更新, 传count，点击add num就不更新，点击add count一并更新；\n\n  return /*#__PURE__*/_jsxs(_Fragment, {\n    children: [/*#__PURE__*/_jsxs(\"div\", {\n      children: [/*#__PURE__*/_jsx(\"h2\", {\n        children: \"\\u8BA1\\u6570\\u5668:\"\n      }), \" count\\uFF1A--- \", res.count, /*#__PURE__*/_jsx(\"br\", {}), \"num: --- \", res.num]\n    }), /*#__PURE__*/_jsx(\"button\", {\n      type: \"button\",\n      onClick: () => setCount(count + 1),\n      children: \"add count\"\n    }), /*#__PURE__*/_jsx(\"button\", {\n      type: \"button\",\n      onClick: () => setNum(num + 1),\n      children: \"add num\"\n    }), /*#__PURE__*/_jsx(\"hr\", {}), /*#__PURE__*/_jsx(ChildMemo, _objectSpread({}, {\n      count,\n      num\n    }))]\n  });\n};\n\nexport default UseMemoDemo;","map":null,"metadata":{},"sourceType":"module"}